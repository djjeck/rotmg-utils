<html>
  <head>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script type="text/javascript">
      const ENOUGH_ARMOR_ENOUGH = 1;
      const ENOUGH_WEAPON_ENOUGH = 2;
      
      const LogLevel = {
        DEBUG: 1,
        INFO: 2,
        WARNING: 3,
        ERROR: 4,
      };
      
      class Logger {
        constructor() {
          this.logLevel = LogLevel.INFO;
        }
        
        setLogLevel(level) {
          this.logLevel = level;
        }
        
        log(level, message) {
          if (level >= this.logLevel) {
            console.log(message);
          }
        }
      }
    </script>
    <script type="text/javascript">
      const Tier = {
        T7: 7,
        T8: 8,
        T9: 9,
      };
      
      const ItemType = {
        ARMOR: 1,
        WEAPON: 2,
      };
      
      const ArmorType = {
        LEATHER: 1,
        ROBE: 2,
        HEAVY: 3,
      };
      
      const WeaponType = {
        DAGGER: 1,
        BOW: 2,
        STAFF: 3,
        WAND: 4,
        SWORD: 5,
        KATANA: 6,
      };
      
      class Keys {
        getTierKey(tier) {
          let tierKey;
          switch (tier) {
            case Tier.T7: return 't7';
            case Tier.T8: return 't8';
            case Tier.T9: return 't9';
            default: throw `Invalid tier: ${tier}`;
          }
        }
        
        makeItemKey(tier, type, itemClass) {
          const tierKey = this.getTierKey(tier);
          let typeKey;
          let classKey;
          switch (type) {
            case ItemType.ARMOR:
              typeKey = 'armor';
              switch (itemClass) {
                case ArmorType.LEATHER: classKey = 'leather'; break;
                case ArmorType.ROBE: classKey = 'robe'; break;
                case ArmorType.HEAVY: classKey = 'heavy'; break;
                default: throw `Invalid armor class: ${itemClass}`;
              }
              break;
            case ItemType.WEAPON:
              typeKey = 'weapon';
              switch (itemClass) {
                case WeaponType.DAGGER: classKey = 'dagger'; break;
                case WeaponType.BOW: classKey = 'bow'; break;
                case WeaponType.STAFF: classKey = 'staff'; break;
                case WeaponType.WAND: classKey = 'wand'; break;
                case WeaponType.SWORD: classKey = 'sword'; break;
                case WeaponType.KATANA: classKey = 'katana'; break;
                default: throw `Invalid armor class: ${itemClass}`;
              }
              break;
            default: throw `Invalid type: ${type}`;
          }
          return `${tierKey}-${typeKey}-${classKey}`;
        }
        
        makeItemImageKey(tier, type, itemClass) {
          const itemKey = this.makeItemKey(tier, type, itemClass);
          return itemKey;
        }
        
        makeItemQuantityKey(tier, type, itemClass) {
          const itemKey = this.makeItemKey(tier, type, itemClass);
          return `quantity-${itemKey}`;
        }
        
        makeRewardKey(tier) {
          const tierKey = this.getTierKey(tier);
          return `reward-${tierKey}`;
        }
        
        makeConfigKeyEnough(type) {
          let typeKey;
          switch (type) {
            case ItemType.ARMOR: typeKey = 'armors'; break;
            case ItemType.WEAPON: typeKey = 'weapons'; break;
            default: throw `Invalid type: ${type}`;
          }
          return `enough-${typeKey}`;
        }
      }
      
      class Storage {
        constructor() {
          this.cache = {};
        }
        
        readBoolean(key, defaultValue = false) {
          const stringValue = this.readString(key, defaultValue);
          return stringValue === 'true';
        }
        
        writeBoolean(key, value) {
          this.writeString(key, value);
        }
        
        readNumber(key, defaultValue = 0) {
          const stringValue = this.readString(key, defaultValue);
          return parseFloat(stringValue);
        }
        
        writeNumber(key, value) {
          this.writeString(key, value);
        }
        
        readString(key, defaultValue = '') {
          defaultValue += '';
          
          if (key in this.cache) {
            logger.log(LogLevel.DEBUG, `reading ${key} -> ${this.cache[key]} (cached)`);
            return this.cache[key];
          }
          const value = localStorage.getItem(key);
          if (value === null) {
            logger.log(LogLevel.DEBUG, `setting default for ${key} <- ${defaultValue}`);
            this.writeString(key, defaultValue);
            return defaultValue;
          }
          this.cache[key] = value;
          logger.log(LogLevel.DEBUG, `reading ${key} -> ${value}`);
          return value;          
        }
        
        writeString(key, value) {
          value += '';
          
          // Do not store the default value of these special flags into the storage.
          // This reduces the discoverability of the flags, for example from the
          // exported files. 
          if (
            (key == 'log-level' && value == 'INFO') ||
            // This flag is really only meant for excluding myself (djjeck)
            // from Google Analytics.
            // If you're reading this comment and found out about the flag,
            // feel free to enable it, in order to use this tool without
            // leaving a trace. Just remember that the more users in
            // Google Analytics I see, the happier I am.
            (key == 'use-google-analytics' && value == 'true')
          ) {
            localStorage.removeItem(key);
            return;
          }
          
          logger.log(LogLevel.DEBUG, `writing ${key} <- ${value}`);
          this.cache[key] = value;
          localStorage.setItem(key, value);
        }
        
        clear() {
          localStorage.clear();
          this.cache = {};
        }
        
        dumpCache() {
          // Clone cache.
          return Object.assign({}, this.cache);
        }
        
        importCache(json) {
          this.cache = JSON.parse(json);
          // Assuming no values need to be deleted.
          for (const key in this.cache) {
            if (!key.startsWith('_')) { // Skip "comment" values.
              this.writeString(key, this.cache[key]);
            }
          }
        }
      }
      
      class Images {
        getItemImage(tier, type, itemClass) {
          const imageKey = keys.makeItemImageKey(tier, type, itemClass);
          return `img/${imageKey}.png`;
        }
        
        getRewardImages(tier) {
          switch (tier) {
            case Tier.T7: return [
              'img/xp-booster-1.png',
            ];
            case Tier.T8: return [
              'img/loot-tier-potion.png',
              'img/loot-drop-potion.png',
            ];
            case Tier.T9: return [
              'img/stat-pot-vit.png',
              'img/stat-pot-wis.png',
            ];
            default: throw `Unknown tier: ${tier}`;
          }
        }
      }
      
      const logger = new Logger();
      const keys = new Keys();
      const storage = new Storage();
      const images = new Images();
      
      logger.setLogLevel(LogLevel[storage.readString('log-level', 'INFO')]);
      
      function bodyLoad() {
        // Initialize config first, for defaults.
        initConfig();
        render();
        initExport();
      }
      
      function render() {
        const containerEl = document.createElement('div');
        containerEl.className = 'itemsContainer';
        const contentEl = document.getElementById('content');
        contentEl.appendChild(containerEl);
        
        for (const tier of Object.values(Tier)) {
          const rowEl = document.createElement('div');
          rowEl.className = 'row';
          
          // Render armors.
          for (const armorType of Object.values(ArmorType)) {
            rowEl.appendChild(renderItem(tier, ItemType.ARMOR, armorType));
          }
          
          // Render weapons.
          for (const weaponType of Object.values(WeaponType)) {
            rowEl.appendChild(renderItem(tier, ItemType.WEAPON, weaponType));
          }
          
          // Render rewards.
          const rewardsTemplate = document.importNode(document.querySelector('#rewardsTemplate').content, true);
          const rewardsEl = rewardsTemplate.querySelector('.rewards');
          rewardsEl.id = keys.makeRewardKey(tier);
          const rewardContainer = rewardsTemplate.querySelector('.rewardContainer');
          for (const reward of images.getRewardImages(tier)) {
            const rewardTemplate = document.importNode(document.querySelector('#rewardTemplate').content, true);
            const imageEl = rewardTemplate.querySelector('.rewardImage');
            imageEl.src = reward;
            rewardContainer.appendChild(rewardTemplate);
          }
          rowEl.appendChild(rewardsEl);
          
          containerEl.appendChild(rowEl);
          
          decorateRewards(tier);
        }
      }
      
      function renderItem(tier, type, itemClass) {
        const key = keys.makeItemQuantityKey(tier, type, itemClass);
        const src = images.getItemImage(tier, type, itemClass);
        let quantity = storage.readNumber(key);
        const id = `item-${key}`;
        
        const itemTemplate = document.importNode(document.querySelector('#itemTemplate').content, true);
        const itemEl = itemTemplate.querySelector('.item');
        const imageEl = itemTemplate.querySelector('.itemImage');
        const quantityEl = itemTemplate.querySelector('.quantity');
        const [quantityLessEl, quantityMoreEl] = itemTemplate.querySelectorAll('.quantityButton');
        
        itemEl.id = id;
        
        const updateQuantity = () => {
          quantityEl.textContent = quantity;
          quantityLessEl.classList.toggle('disabled', quantity == 0);
          decorateQuantity(itemEl, type, quantity);
        }
        
        const increaseQuantity = () => {
          quantity++;
          storage.writeNumber(key, quantity);
          decorateRewards(tier);
          updateQuantity();
        };
        
        const decreaseQuantity = () => {
          if (quantity == 0) {
            return;
          }
          quantity--;
          storage.writeNumber(key, quantity);
          decorateRewards(tier);
          updateQuantity();
        };
        
        imageEl.src = src;
        quantityLessEl.onclick = decreaseQuantity;
        quantityMoreEl.onclick = increaseQuantity;
        updateQuantity();
        
        return itemEl;
      }
      
      function initConfig() {
        const enoughArmor = storage.readNumber(keys.makeConfigKeyEnough(ItemType.ARMOR), ENOUGH_ARMOR_ENOUGH);
        const enoughWeapon = storage.readNumber(keys.makeConfigKeyEnough(ItemType.WEAPON), ENOUGH_WEAPON_ENOUGH);
        
        const enoughArmorInput = document.getElementById('config-enough-armors');
        const enoughWeaponInput = document.getElementById('config-enough-weapons');
        
        enoughArmorInput.value = enoughArmor;
        enoughWeaponInput.value = enoughWeapon;
        updateVaultSlotsConfig();
        
        enoughArmorInput.onclick = () => {
          storage.writeNumber(keys.makeConfigKeyEnough(ItemType.ARMOR), enoughArmorInput.value);
          updateVaultSlotsConfig();
          decorateQuantities('armors');
        };
        enoughWeaponInput.onclick = () => {
          storage.writeNumber(keys.makeConfigKeyEnough(ItemType.WEAPON), enoughWeaponInput.value);
          updateVaultSlotsConfig();
          decorateQuantities('weapons');
        };
      }
      
      function initExport() {
        if (!Blob || !FileReader) {
          logger.log(LogLevel.WARNING, 'Exporting to a file is not supported');
          return;
        }
        
        const exportTemplate = document.importNode(document.querySelector('#exportTemplate').content, true);
        const exportEl = exportTemplate.querySelector('#export');
        const exportButton = exportTemplate.querySelector('#exportButton');
        const importButton = exportTemplate.querySelector('#importButton');
        const resetButton = exportTemplate.querySelector('#resetButton');
        
        exportButton.onclick = () => {
          // Assuming all necessary values have been read once.
          const cache = storage.dumpCache();
          // Comments are not allowed in JSON. Using properties prefixed with _ (they go at the end).
          cache['_'] = ''; // Just a spacer.
          cache['_exported-from'] = 'http://www.djjeck.com/projects/rotmg/tinkerer-items.html';
          cache['_exported-on'] = new Date().toISOString();
          
          // Adapted from https://stackoverflow.com/a/30832210.
          const file = new Blob([JSON.stringify(cache, null, '  ')], {type: 'text/plain'});
          const filename = 'tinkerer-items.json';
          
          if (navigator.msSaveOrOpenBlob) { // IE10+
            navigator.msSaveOrOpenBlob(file, filename);
            logger.log(LogLevel.INFO, 'Data exported successfully');
          } else {
            const url = URL.createObjectURL(file);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            logger.log(LogLevel.INFO, 'Data exported successfully');
            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 0);
          }
        };
        
        importButton.onclick = () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.style.display = 'none';
          input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = e => {
              // TODO make sure the file actually is a cache dump.
              storage.importCache(e.target.result);
              logger.log(LogLevel.INFO, 'Data imported successfully');
              // Refresh the whole page, i.e. the lazy way.
              window.location.reload();
            };
            reader.readAsText(file);
          };
          document.body.appendChild(input);
          input.click();
        };
        
        resetButton.onclick = () => {
          const confirmation = confirm('All item quantities will be set to 0\n\nAre you sure?');
          if (confirmation) {
            storage.clear();
            // Refresh the whole page, i.e. the lazy way.
            window.location.reload();
          }
        };
        
        document.getElementById('exportContainer').appendChild(exportEl);
      }
      
      function updateVaultSlotsConfig() {
        const vaultSlots = 3 * (
          storage.readNumber(keys.makeConfigKeyEnough(ItemType.ARMOR)) * 3 +
          storage.readNumber(keys.makeConfigKeyEnough(ItemType.WEAPON)) * 6);
        
        const vaultChestsInput = document.getElementById('config-vault-chests');
        const vaultSlotsInput = document.getElementById('config-vault-slots');
        vaultChestsInput.value = formatFloat(vaultSlots / 8);
        vaultSlotsInput.value = vaultSlots;
      }
      
      function decorateQuantities(type) {
        for (const tier of Object.values(Tier)) {
          for (const type of Object.values(ItemType)) {
            let itemClasses;
            switch (type) {
              case ItemType.ARMOR: itemClasses = Object.values(ArmorType); break;
              case ItemType.WEAPON: itemClasses = Object.values(WeaponType); break;
              default: throw `Invalid type: ${type}`;
            }
            for (const itemClass of itemClasses) {
              const key = keys.makeItemQuantityKey(tier, type, itemClass);
              const id = `item-${key}`;
              const itemEl = document.getElementById(id);
              decorateQuantity(itemEl, type, storage.readNumber(key));
            }
          }
        }
      }
      
      function decorateQuantity(element, type, quantity) {
        element.classList.toggle('missing', quantity == 0);
        element.classList.toggle('enough', quantity >= storage.readNumber(keys.makeConfigKeyEnough(type)));
      }
      
      function decorateRewards(tier) {
        const itemKeys = [
          ...Object.values(ArmorType).map(armorType => keys.makeItemQuantityKey(tier, ItemType.ARMOR, armorType)),
          ...Object.values(WeaponType).map(weaponType => keys.makeItemQuantityKey(tier, ItemType.WEAPON, weaponType))
        ];
        
        const ownedItems = itemKeys.filter(key => storage.readNumber(key) > 0).length;
        const totalItems = itemKeys.length;
        const pct = 100 * ownedItems / totalItems;
        
        const rewardEl = document.getElementById(keys.makeRewardKey(tier));
        rewardEl.classList.toggle('missing', ownedItems == 0);
        rewardEl.classList.toggle('complete', ownedItems == totalItems);
        rewardEl.querySelector('.progressBar').style.width = `${pct}%`;
      }
      
      function formatFloat(number) {
        return Math.floor(number * 100) / 100;
      }
      
      const useGoogleAnalytics = storage.readBoolean('use-google-analytics', true);
      if (useGoogleAnalytics) {
        // Google Analytics.
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-9512500-11', 'auto');
        ga('send', 'pageview');
      }
    </script>
    <title>Tinkerer items</title>
  </head>
  <body onload="bodyLoad();">
    <div class="tinkerer">
      <img class="sprite" src="img/tinkerer.png" />
    </div>
    <div id="content" class="module">
    </div>
    <div id="config" class="module">
      <label>
        <span class="label">Enough armors</span>
        <input id="config-enough-armors" type="number" min="1" max="99" />
      </label>
      <label>
        <span class="label">Enough weapons</span>
        <input id="config-enough-weapons" type="number" min="1" max="99" />
      </label>
      
      <label>
        <span class="label">Vault chests</span>
        <input id="config-vault-chests" type="number" min="1" max="80" disabled="disabled" />
      </label>
      <label>
        <span class="label">Vault slots</span>
        <input id="config-vault-slots" type="number" min="1" max="640" disabled="disabled" />
      </label>
    </div>
    <div id="exportContainer" class="module">
    </div>
    <div id="footer" class="module">
      Made by <a href="http://realmeye.com/player/djjeck">djjeck</a>.
      Source on <a href="https://github.com/djjeck/rotmg-utils">GitHub</a>
      <br>
      For bugs, ideas, and updating content, <a href="https://github.com/djjeck/rotmg-utils/issues">create an issue</a>
      <br>
      If you find this useful, pot donations are welcome :)
    </div>
    
    <template id="itemTemplate">
      <div class="item">
        <img class="sprite itemImage" />
        <div class="quantityContainer">
          <!-- White Down-Pointing Triangle https://unicode-table.com/en/25BD/ -->
          <span class="quantityButton">&#x25BD;</span>
          <span class="quantity"></span>
          <!-- White Up-Pointing Triangle https://unicode-table.com/en/25B3/ -->
          <span class="quantityButton">&#x25B3;</span>
        </div>
      </div>
    </template>
    
    <template id="rewardsTemplate">
      <div class="rewards">
        <div class="rewardContainer"></div>
        <div class="progressBarContainer">
          <div class="progressBar"></div>
        </div>
      </div>
    </template>
    
    <template id="rewardTemplate">
      <img class="sprite rewardImage" />
    </template>
    
    <template id="exportTemplate">
      <div id="export">
        <button id="exportButton">Export</button>
        <button id="importButton">Import</button>
        <button id="resetButton">Reset data</button>
      </div>
    </template>

    <!-- Fork me on GitHub ribbon, from https://github.com/blog/273-github-ribbons -->
    <a class="githubBanner" href="https://github.com/djjeck/rotmg-utils">
      <img src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png">
    </a>
  </body>
</html>

